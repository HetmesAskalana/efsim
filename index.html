<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>终末地源石电路修复计算器</title>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Z52CM5VFN5"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-Z52CM5VFN5');
    </script>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0; padding: 0;
            font-family: "Helvetica Neue", Arial, sans-serif;
            background: #f0f2f5;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px 10px;
        }
        #app {
            max-width: 1000px;
            width: 100%;
            border-radius: 12px;
            background: white;
            box-shadow:
                0 8px 16px rgb(0 0 0 / 0.1);
            padding: 16px 20px 32px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            margin: 0 0 20px 0;
            font-weight: 700;
            font-size: 1.6rem;
            color: #2c3e50;
            user-select: none;
        }
        #input-area {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 24px;
            flex-wrap: wrap;
            justify-content: center;
        }
        #input-area label {
            font-weight: 600;
            font-size: 1rem;
            color: #34495e;
            user-select: none;
        }
        #input-area input[type=number] {
            border: 1.8px solid #ccc;
            border-radius: 8px;
            outline-offset: 0;
            padding: 6px 12px;
            width: 72px;
            font-size: 1rem;
            text-align: center;
            transition: border-color 0.3s ease;
        }
        #input-area input[type=number]:focus {
            border-color: #409eff;
        }
        #input-area button {
            background-color: #409eff;
            border: none;
            color: white;
            font-weight: 600;
            font-size: 1rem;
            padding: 8px 24px;
            border-radius: 12px;
            cursor: pointer;
            transition: background-color 0.25s ease;
            user-select: none;
        }
        #input-area button:hover {
            background-color: #66b1ff;
        }
        #tool-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            width: 100%;
            max-width: 980px;
            gap: 24px;
            user-select: none;
        }
        .board-wrapper {
            position: relative;
            display: flex;
        }
        .grid-container {
            display: grid;
            background: #fafafa;
            border-radius: 12px;
            box-shadow:
                inset 0 0 3px #bbb;
            user-select: none;
        }
        .row-inputs, .col-inputs {
            display: grid;
            gap: 3px;
        }
        .row-inputs {
            grid-auto-flow: row;
            justify-items: right;
            align-content: start;
            padding-right: 6px;
            margin-right: 8px;
            border-right: 1px solid #ddd;
        }
        .row-inputs input {
            width: 32px;
            text-align: center;
            border: 1.5px solid #ccc;
            border-radius: 8px;
            font-weight: 600;
            user-select: text;
            padding: 4px 6px;
            background: #fff;
            transition: border-color 0.3s ease;
        }
        .row-inputs input:focus {
            border-color: #409eff;
        }
        .col-inputs {
            grid-auto-flow: column;
            justify-content: start;
            align-items: center;
            gap: 3px;
            margin-bottom: 8px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 6px;
        }
        .col-inputs input {
            width: 32px;
            text-align: center;
            border: 1.5px solid #ccc;
            border-radius: 8px;
            font-weight: 600;
            user-select: text;
            padding: 4px 6px;
            background: #fff;
            transition: border-color 0.3s ease;
        }
        .col-inputs input:focus {
            border-color: #409eff;
        }
        .corner-box {
            width: 40px;
            height: 40px;
        }
        #board {
            display: grid;
            background-color: #fff;
            border-radius: 12px;
            box-shadow:
                inset 0 0 5px #ccc;
            user-select: none;
            touch-action: manipulation;
        }
        .cell {
            border: 1.2px solid #ddd;
            background-color: white;
            border-radius: 8px;
            position: relative;
            cursor: pointer;
            transition:
                background-color 0.3s ease,
                border-color 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .cell.disabled {
            background:
                repeating-linear-gradient(
                    135deg,
                    #aaa,
                    #aaa 2px,
                    #bbb 2px,
                    #bbb 4px
                );
            border-color: #999;
            cursor: pointer;
        }
        .cell.placed {
            color: #222;
            font-weight: 600;
            z-index: 2;
        }
        .cell.placed.type1 {
            background-color: rgba(126, 211, 33, 0.6);
            border-color: #5db417;
        }
        .cell.placed.type2 {
            background-color: rgba(144, 202, 249, 0.6);
            border-color: #1976d2;
        }
        .cell .comp-label {
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 0.75rem;
            font-weight: 700;
            user-select: none;
            color: rgba(0,0,0,0.3);
        }
        .cell.locked {
            position: relative;
            background-color: #a6f7a6;
            border-color: #28c4eb;
            cursor: pointer;
            background:
                repeating-linear-gradient(
                    45deg,
                    #a6f7a6,
                    #a6f7a6 2px,
                    #7ed321 2px,
                    #7ed321 4px
                );
        }
        .cell.locked::after {
            content: "";
            position: absolute;
            width: 18px;
            height: 18px;
            top: 5px;
            left: 5px;
            background-image:
                linear-gradient(45deg, transparent 44%, #2ecc40 45%, #2ecc40 55%, transparent 56%),
                linear-gradient(-45deg, transparent 44%, #2ecc40 45%, #2ecc40 55%, transparent 56%);
            pointer-events: none;
        }
        .cell.relocked {
            position: relative;
            background-color: #90caf9;
            border-color: #1976d2;
            cursor: pointer;
            background:
                repeating-linear-gradient(
                    45deg,
                    #90caf9,
                    #90caf9 2px,
                    #64b5f6 2px,
                    #64b5f6 4px
                );
        }
        .cell.relocked::after {
            content: "";
            position: absolute;
            width: 18px;
            height: 18px;
            top: 5px;
            left: 5px;
            background-image:
                linear-gradient(45deg, transparent 44%, #1565c0 45%, #1565c0 55%, transparent 56%),
                linear-gradient(-45deg, transparent 44%, #1565c0 45%, #1565c0 55%, transparent 56%);
            pointer-events: none;
        }
        .cell.disabled::after {
            content: "";
            position: absolute;
            width: 18px;
            height: 18px;
            top: 5px;
            left: 5px;
            background-image:
                linear-gradient(45deg, transparent 44%, #666 45%, #666 55%, transparent 56%),
                linear-gradient(-45deg, transparent 44%, #666 45%, #666 55%, transparent 56%);
            pointer-events: none;
        }
        #components-panel {
            flex-shrink: 0;
            min-width: 260px;
            max-width: 325px;
            border-radius: 12px;
            background-color: #f9fafb;
            border: 1.5px solid #ddd;
            padding: 14px 14px 20px 14px;
            box-shadow:
                0 4px 10px rgb(0 0 0 / 0.05);
            display: flex;
            flex-direction: column;
            user-select: none;
            max-height: calc(100vh - 200px);
        }
        #components-panel h2 {
            margin: 0 0 16px 0;
            text-align: center;
            font-weight: 700;
            font-size: 1.3rem;
            color: #34495e;
            flex-shrink: 0;
        }
        .component-item {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        #components-scroll-wrapper {
            max-height: 225px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 14px;
            flex: 1;
            margin-bottom: 12px;
        }
        #components-scroll-wrapper::-webkit-scrollbar #preset-list-wrapper::-webkit-scrollbar {
            width: 8px;
        }
        #components-scroll-wrapper::-webkit-scrollbar-track #preset-list-wrapper::-webkit-scrollbar-track {
            background: #f9fafb;
            border-radius: 8px;
        }
        #components-scroll-wrapper::-webkit-scrollbar-thumb #preset-list-wrapper::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 8px;
        }
        #components-scroll-wrapper::-webkit-scrollbar-thumb:hover #preset-list-wrapper::-webkit-scrollbar-thumb:hover {
            background: #999;
        }
        .comp-icon {
            border-radius: 8px;
            background-color: #fff;
            box-shadow:
                0 0 6px rgb(0 0 0 / 0.1);
            user-select: none;
            flex-shrink: 0;
        }
        .comp-count-input {
            width: 52px;
            border-radius: 8px;
            border: 1.8px solid #ccc;
            font-weight: 600;
            font-size: 1rem;
            padding: 5px 8px;
            text-align: center;
            background: white;
            transition: border-color 0.3s ease;
        }
        .comp-count-input:focus {
            border-color: #409eff;
            outline: none;
        }
        .row-inputs-type2, .col-inputs-type2 {
            display: grid;
            gap: 3px;
            background-color: #e3f2fd;
            border-radius: 4px;
        }
        .row-inputs-type2 input, .col-inputs-type2 input {
            border: 1.5px solid #90caf9;
            background-color: #f5f9ff;
            width: 32px;
            text-align: center;
            border-radius: 8px;
            font-weight: 600;
            user-select: text;
            padding: 4px 6px;
            transition: border-color 0.3s ease;
        }
        .row-inputs-type2 input:focus, .col-inputs-type2 input:focus {
            border-color: #1976d2;
            background-color: #fff;
        }
        /* Buttons */
        .button-group-button {
            font-weight: 700;
            font-size: 1.15rem;
            border: none;
            padding: 10px 40px;
            border-radius: 14px;
            cursor: pointer;
            box-shadow: 0 3px 8px rgb(0 0 0 / 0.15);
            user-select: none;
            transition: background-color 0.3s ease;
            min-width: 120px;
        }
        .button-start {
            background-color: #e74c3c;
            color: white;
        }
        .button-start:hover:not(:disabled) {
            background-color: #ff6050;
        }
        .button-start:disabled {
            background-color: #f5a19a;
            cursor: default;
            box-shadow: none;
        }
        .button-reset {
            background-color: #5dade2;
            color: white;
        }
        .button-reset:hover:not(:disabled) {
            background-color: #85c1e9;
        }
        .button-reset:disabled {
            background-color: #aed6f1;
            cursor: default;
            box-shadow: none;
        }
        .comp-color-0 { background-color: #ff6b6b; border-color: #d04c4c; } /* red */
        .comp-color-1 { background-color: #4a90e2; border-color: #3672bf; } /* blue */
        .comp-color-2 { background-color: #f5a623; border-color: #c88413; } /* orange */
        .comp-color-3 { background-color: #7ed321; border-color: #5db417; } /* green */
        .comp-color-4 { background-color: #9b59b6; border-color: #753d99; } /* purple */
        .comp-color-5 { background-color: #1abc9c; border-color: #138d7d; } /* teal */
        .comp-color-6 { background-color: #e67e22; border-color: #b36117; } /* dark orange */
        .comp-color-7 { background-color: #34495e; border-color: #1f2a36; } /* dark slate */
        .comp-color-8 { background-color: #c0392b; border-color: #80251f; } /* dark red */
        .comp-color-9 { background-color: #2980b9; border-color: #1d5b7a; } /* dark blue */
        .cell.placed.comp-0 { background-color: rgba(255, 107, 107, 0.85); border: 2px solid #d04c4c; }
        .cell.placed.comp-1 { background-color: rgba(74, 144, 226, 0.85); border: 2px solid #3672bf; }
        .cell.placed.comp-2 { background-color: rgba(245, 166, 35, 0.85); border: 2px solid #c88413; }
        .cell.placed.comp-3 { background-color: rgba(126, 211, 33, 0.85); border: 2px solid #5db417; }
        .cell.placed.comp-4 { background-color: rgba(155, 89, 182, 0.85); border: 2px solid #753d99; }
        .cell.placed.comp-5 { background-color: rgba(26, 188, 156, 0.85); border: 2px solid #138d7d; }
        .cell.placed.comp-6 { background-color: rgba(230, 126, 34, 0.85); border: 2px solid #b36117; }
        .cell.placed.comp-7 { background-color: rgba(52, 73, 94, 0.85); border: 2px solid #1f2a36; }
        .cell.placed.comp-8 { background-color: rgba(192, 57, 43, 0.85); border: 2px solid #80251f; }
        .cell.placed.comp-9 { background-color: rgba(41, 128, 185, 0.85); border: 2px solid #1d5b7a; }
        .comp-icon {
            display: grid;
            place-items: center;
            user-select: none;
        }
        .comp-icon .cell {
            border-width: 1px;
            cursor: default;
            background-color: #fff;
            border-color: #ccc;
        }
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield;
        }
        input[type=checkbox] {
            cursor: pointer;
            width: 18px;
            height: 18px;
        }
        .cell.disabled[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 110%;
            left: 50%;
            transform: translateX(-50%);
            padding: 4px 8px;
            background: #333;
            color: white;
            font-size: 0.75rem;
            border-radius: 6px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0.85;
            z-index: 10;
        }

        .button-mode-input {
            border: none;
            border-radius: 8px;
            font-weight: 700;
            font-size: 0.95rem;
            padding: 6px 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            min-width: 42px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .button-mode-input.type1 {
            background-color: #7ed321;
            color: white;
            border: 2px solid #5db417;
            box-shadow: 0 2px 6px rgba(126, 211, 33, 0.3);
        }
        .button-mode-input.type1:hover {
            background-color: #8fdd2f;
            box-shadow: 0 3px 8px rgba(126, 211, 33, 0.4);
        }
        .button-mode-input.type1:active {
            transform: scale(0.98);
        }
        .button-mode-input.type2 {
            background-color: #64b5f6;
            color: white;
            border: 2px solid #1976d2;
            box-shadow: 0 2px 6px rgba(100, 181, 246, 0.3);
        }
        .button-mode-input.type2:hover {
            background-color: #90caf9;
            box-shadow: 0 3px 8px rgba(100, 181, 246, 0.4);
        }
        .button-mode-input.type2:active {
            transform: scale(0.98);
        }
        .row-buttons, .col-buttons {
            display: grid;
            gap: 3px;
        }
        .row-buttons {
            grid-auto-flow: row;
            justify-items: right;
            align-content: start;
            padding-right: 6px;
            margin-right: 8px;
            border-right: 1px solid #ddd;
        }
        .row-buttons-type2 {
            display: grid;
            gap: 3px;
            padding-right: 6px;
            margin-right: 8px;
            border-right: 1px solid #90caf9;
        }
        .col-buttons {
            grid-auto-flow: column;
            justify-content: start;
            align-items: center;
            gap: 3px;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #ddd;
        }
        .col-buttons-type2 {
            display: grid;
            grid-auto-flow: column;
            justify-content: start;
            align-items: center;
            gap: 3px;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #90caf9;
        }

        @media (max-width: 720px) {
            #tool-container {
                flex-direction: column;
                width: 100%;
                max-width: none;
                align-items: center;
                justify-content: flex-start;
            }
            #author-info {
                position: unset !important;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <h1>终末地源石电路修复计算器</h1>
        <div id="input-area">
            <label for="board-rows">行数</label>
            <input type="number" id="board-rows" min="1" max="10" v-model.number="boardRowsTmp" @keydown.enter.prevent="generateBoard" @change="onRowsChange" />
            <label for="board-cols">列数</label>
            <input type="number" id="board-cols" min="1" max="10" v-model.number="boardColsTmp" @keydown.enter.prevent="generateBoard" />
            <button @click="generateBoard" :disabled="boardRowsTmp < 1 || boardRowsTmp > 10 || boardColsTmp < 1 || boardColsTmp > 10">确定</button>
            <label style="margin-left: 24px; display: flex; align-items: center; gap: 8px; font-weight: 600;">
                <input type="checkbox" v-model="type2Enabled" :disabled="calculateRunning" @change="onType2Toggle" />
                包含蓝色组件
            </label>
            <label style="margin-left: 24px; display: flex; align-items: center; gap: 8px; font-weight: 600;">
                <input type="checkbox" v-model="useButton" :disabled="calculateRunning" @change="onButtonModeToggls" />
                按键输入模式
            </label>
        </div>

        <template v-if="boardGenerated">
            <div id="tool-container" :style="{maxWidth: calculateRunning ? '100vw' : '980px'}">
                <div class="board-wrapper" :style="{gap: '4px'}">
                    <div style="display:flex; flex-direction: column; align-items: flex-end; margin-right: 6px;" :style="{ marginTop: type2Enabled ? (useButton ? '45px' : '30px') : '0' }">
                        <div style="display:flex; gap: 4px; height: 40px;">
                            <div class="corner-box" style="width:40px; height:40px;"></div>
                        </div>
                        <div style="display:flex; gap: 4px;">
                            <div v-if="type2Enabled" :class="useButton ? 'row-buttons-type2' : 'row-inputs-type2'" :style="{gridTemplateRows: `repeat(${boardRows}, 40px)`, display: 'grid', gap: '3px', paddingRight: '6px', marginRight: '8px', borderRight: useButton ? '1px solid #90caf9' : '1px solid #90caf9'}">
                                <template v-if="useButton">
                                    <button v-for="(val, i) in row2Targets"
                                        :key="'rowtarget2-btn-'+i"
                                        class="button-mode-input type2"
                                        @click="incrementTarget('row2', i, boardCols)"
                                        @contextmenu.prevent="decrementTarget('row2', i, boardCols)"
                                        :disabled="calculateRunning"
                                    >
                                        {{ row2Targets[i] }}
                                    </button>
                                </template>
                                <template v-else>
                                    <input type="number" v-for="(val, i) in row2Targets"
                                        :key="'rowtarget2-'+i"
                                        v-model.number="row2Targets[i]"
                                        :min="0"
                                        :max="boardCols"
                                        :disabled="calculateRunning"
                                        @input="validateTarget('row2', i)"
                                    />
                                </template>
                            </div>
                            <div :class="useButton ? 'row-buttons' : 'row-inputs'" :style="{gridTemplateRows: `repeat(${boardRows}, 40px)`}">
                                <template v-if="useButton">
                                    <button v-for="(val, i) in rowTargets"
                                        :key="'rowtarget-btn-'+i"
                                        class="button-mode-input type1"
                                        @click="incrementTarget('row', i, boardCols)"
                                        @contextmenu.prevent="decrementTarget('row', i, boardCols)"
                                        :disabled="calculateRunning"
                                    >
                                        {{ rowTargets[i] }}
                                    </button>
                                </template>
                                <template v-else>
                                    <input type="number" v-for="(val, i) in rowTargets"
                                        :key="'rowtarget-'+i"
                                        v-model.number="rowTargets[i]"
                                        :min="0"
                                        :max="boardCols"
                                        :disabled="calculateRunning"
                                        @input="validateTarget('row', i)"
                                    />
                                </template>
                            </div>
                        </div>
                    </div>

                    <div style="display:flex; flex-direction: column;">
                        <div v-if="type2Enabled" :class="useButton ? 'col-buttons-type2' : 'col-inputs-type2'" :style="{gridTemplateColumns: `repeat(${boardCols}, 40px)`, marginBottom: '8px', paddingBottom: '6px', borderBottom: useButton ? '1px solid #90caf9' : '1px solid #90caf9'}">
                            <template v-if="useButton">
                                <button v-for="(val, j) in col2Targets"
                                    :key="'coltarget2-btn-'+j"
                                    class="button-mode-input type2"
                                    @click="incrementTarget('col2', j, boardRows)"
                                    @contextmenu.prevent="decrementTarget('col2', j, boardRows)"
                                    :disabled="calculateRunning"
                                >
                                    {{ col2Targets[j] }}
                                </button>
                            </template>
                            <template v-else>
                                <input type="number" v-for="(val, j) in col2Targets"
                                    :key="'coltarget2-'+j"
                                    v-model.number="col2Targets[j]"
                                    :min="0"
                                    :max="boardRows"
                                    :disabled="calculateRunning"
                                    @input="validateTarget('col2', j)"
                                />
                            </template>
                        </div>
                        <div :class="useButton ? 'col-buttons' : 'col-inputs'" :style="{gridTemplateColumns: `repeat(${boardCols}, 40px)`}">
                            <template v-if="useButton">
                                <button v-for="(val, j) in colTargets"
                                    :key="'coltarget-btn-'+j"
                                    class="button-mode-input type1"
                                    @click="incrementTarget('col', j, boardRows)"
                                    @contextmenu.prevent="decrementTarget('col', j, boardRows)"
                                    :disabled="calculateRunning"
                                >
                                    {{ colTargets[j] }}
                                </button>
                            </template>
                            <template v-else>
                                <input type="number" v-for="(val, j) in colTargets"
                                    :key="'coltarget-'+j"
                                    v-model.number="colTargets[j]"
                                    :min="0"
                                    :max="boardRows"
                                    :disabled="calculateRunning"
                                    @input="validateTarget('col', j)"
                                />
                            </template>
                        </div>
                        <div id="board" :style="{gridTemplateColumns: `repeat(${boardCols}, 40px)`, gridTemplateRows: `repeat(${boardRows}, 40px)`, width: 40*boardCols + 'px', height: 40*boardRows + 'px'}">
                            <div class="cell"
                                v-for="(cell, idx) in cells"
                                :key="idx"
                                :class="[
                                    { 
                                        disabled: !cell.placed && cell.state === 1, 
                                        locked: !cell.placed && cell.state === 2, 
                                        relocked: !cell.placed && cell.state === 3, 
                                        placed: cell.placed,
                                        type1: cell.placed && cell.state === 2, 
                                        type2: cell.placed && cell.state === 3
                                    },
                                ]"
                                :style="cell.placed ? getCellBorderStyle(cell, idx) : {}"
                                @click="toggleDisableCell(cell)"
                            >
                                <div v-if="cell.placed" class="comp-label">{{ cell.compInstanceId }}</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="components-panel">
                    <h2>组件列表</h2>
                    <div id="components-scroll-wrapper">
                        <div class="component-item" v-for="(comp, index) in components" :key="'comp-'+index" :style="{gap:'10px'}">
                            <!-- <div style="font-weight: 600; font-size: 1rem; color: #2c3e50; min-width: 60px; user-select:none; display: flex; align-items: center;">
                                {{ comp.name }}
                            </div> -->
                            <div class="comp-icon"
                                :style="{
                                    gridTemplateColumns: `repeat(${comp.sizeCols}, 20px)`,
                                    gridTemplateRows: `repeat(${comp.sizeRows}, 20px)`,
                                    width: comp.sizeCols * 20 + 'px',
                                    height: comp.sizeRows * 20 + 'px',
                                    backgroundColor: '#fff',
                                    boxShadow: '0 0 6px rgba(0,0,0,0.12)',
                                    borderRadius: '8px'
                                }"
                            >
                                <div v-for="r in comp.sizeRows" :key="'row'+r" style="display:contents;">
                                    <div v-for="c in comp.sizeCols" :key="'cell-'+r+'-'+c"
                                        class="cell"
                                        :style="{
                                            width: '20px',
                                            height: '20px',
                                            border: '1px solid #ccc',
                                            borderRadius: '6px',
                                            backgroundColor: comp.shapeSet.has((r-1)+','+(c-1)) ? comp.color : '#fff',
                                            opacity: comp.shapeSet.has((r-1)+','+(c-1)) ? 1 : 0,
                                            cursor: 'default'
                                        }"
                                    ></div>
                                </div>
                            </div>
                            <div style="display: flex; gap: 6px;">
                                <input type="number" min="0" max="99" class="comp-count-input" v-model.number="comp.count" :disabled="calculateRunning" title="绿色组件数量" />
                                <input v-if="type2Enabled" type="number" min="0" max="99" class="comp-count-input" v-model.number="comp.count2" :disabled="calculateRunning" title="蓝色组件数量" :style="{backgroundColor: '#e3f2fd', borderColor: '#90caf9'}" />
                            </div>
                        </div>
                    </div>
                    如果没有您要找的组件请尝试<br/><button
                        class="button-group-button button-reset"
                        @click="refreshComponents"
                        :disabled="calculateRunning"
                        style="font-size: 0.9rem; padding: 6px 16px; vertical-align: middle;"
                    >刷新组件列表</button>
                </div>
            </div>
            <div style="margin-top: 24px; display: flex; justify-content:center; gap: 16px; flex-wrap: wrap;">
                <button
                    class="button-group-button button-start"
                    @click="startCalculation"
                    :disabled="calculateRunning"
                >开始计算</button>
                <button
                    class="button-group-button button-reset"
                    @click="resetAnswer"
                    :disabled="calculateRunning || !boardGenerated"
                >重置答案</button>
                <button
                    class="button-group-button button-reset"
                    @click="resetAll"
                    :disabled="calculateRunning || !boardGenerated"
                >重置全部</button>
                <button
                    class="button-group-button button-reset"
                    @click="exportPreset"
                    :disabled="!answerPlaced || calculateRunning"
                    style="padding: 6px 16px;"
                    >导出当前预设</button>
            </div>
            <div v-if="calculateResultMessage" style="margin-top: 16px; font-weight: 600; font-size: 1.1rem; text-align: center; color: #e74c3c;">
                {{calculateResultMessage}}
            </div>
            <div v-if="boardGenerated && Object.keys(presets).length > 0" style="margin-top: 24px; width: 100%; max-width: 600px; margin-left: auto; margin-right: auto;">
                <h3 style="margin: 0 0 16px 0; text-align: center; font-weight: 700; font-size: 1.2rem; color: #34495e;">导入攻略预设</h3>
                <div style="margin-bottom: 12px;">
                    <input 
                        type="text" 
                        v-model="presetSearchText"
                        @input="onPresetSearchInput"
                        placeholder="搜索预设名称..." 
                        style="width: 100%; padding: 10px 12px; border: 1.8px solid #ccc; border-radius: 8px; font-size: 1rem; transition: border-color 0.3s ease; font-weight: 500;"
                        @focus="(e) => !calculateRunning && (e.target.style.borderColor = '#409eff')"
                        @blur="(e) => e.target.style.borderColor = '#ccc'"
                        :disabled="calculateRunning"
                    />
                </div>
                <div style="border: 1.8px solid #ddd; border-radius: 8px; background: #fafafa; max-height: 240px; overflow-y: auto; margin-bottom: 12px;">
                    <div v-if="presetList.length === 0" style="padding: 20px; text-align: center; color: #999; font-size: 0.95rem;">
                        {{ presetSearchText ? '未找到匹配的预设' : '暂无可用预设' }}
                    </div>
                    <div 
                        v-for="item in presetList" 
                        :key="item.id"
                        @click="selectPreset(item.id)"
                        :style="{
                            padding: '12px 16px',
                            borderBottom: '1px solid #eee',
                            cursor: calculateRunning ? 'default' : 'pointer',
                            backgroundColor: selectedPresetId === item.id ? '#bbdefb' : 'white',
                            transition: 'background-color 0.2s ease',
                            fontWeight: selectedPresetId === item.id ? '600' : '500',
                            color: '#2c3e50',
                            userSelect: 'none',
                        }"
                        @mouseenter="(e) => !calculateRunning && (e.currentTarget.style.backgroundColor = selectedPresetId === item.id ? '#bbdefb' : '#f5f5f5')"
                        @mouseleave="(e) => !calculateRunning && (e.currentTarget.style.backgroundColor = selectedPresetId === item.id ? '#bbdefb' : 'white')"
                    >
                        {{ item.name }}
                    </div>
                </div>
                <div style="margin-top: 12px; display: flex; justify-content:center; gap: 3px; flex-wrap: wrap; font-size: 1rem">
                    <button
                        class="button-group-button button-reset"
                        @click="applyPreset"
                        :disabled="!selectedPresetId || calculateRunning"
                        style="width: 67%;"
                    >
                        应用预设
                    </button>
                    <button
                        class="button-group-button button-reset"
                        @click="refreshPresets"
                        :disabled="calculateRunning"
                    >
                        刷新预设列表
                    </button>
                    <button
                        class="button-group-button button-reset"
                        @click="importPreset"
                        :disabled="calculateRunning"
                        style="width: 100%;"
                    >
                        导入预设
                    </button>
                </div>
            </div>
        </template>
        <div id="author-info" style="position: fixed; right: 12px; bottom: 12px; color: #4a4a4a; font-size: 0.9rem; font-weight: 500; user-select: none; pointer-events: none; z-index: 1000;">
            By HetmesAskalana
        </div>
    </div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script>
        const modelUrl = './config.json';
        const app = Vue.createApp({
            el: "#app",
            data() {
                return {
                    boardRows: 4,
                    boardCols: 4,
                    boardRowsTmp: 4,
                    boardColsTmp: 4,
                    boardGenerated: false,
                    rowTargets: [],
                    colTargets: [],
                    row2Targets: [],
                    col2Targets: [],
                    type2Enabled: false,
                    useButton: false,
                    cells: [],
                    components: [],
                    calculateRunning: false,
                    answerPlaced: false,
                    calculateResultMessage: "",
                    placeResult: null,
                    modelLoaded: false,
                    placedInstances: [],
                    presets: {},
                    presetList: [],
                    presetSearchText: "",
                    selectedPresetId: null,
                };
            },
            methods: {
                async loadComponentsFromServer(){
                    try {
                        const res = await fetch(`./config.json?t=${Date.now()}`);
                        if(!res.ok) throw new Error('加载组件定义失败');
                        const json = await res.json();

                        this.components = Object.entries(json).map(([id, item]) => {
                            let coords = item.shape.map(pair => pair.join(','));
                            let minX = Math.min(...item.shape.map(p => p[0]));
                            let maxX = Math.max(...item.shape.map(p => p[0]));
                            let minY = Math.min(...item.shape.map(p => p[1]));
                            let maxY = Math.max(...item.shape.map(p => p[1]));
                            let normShape = new Set();
                            item.shape.forEach(([x,y]) => {
                                normShape.add((x - minX) + ',' + (y - minY));
                            });
                            return {
                                id: id,
                                name: item.name,
                                shapeSet: normShape,
                                color: item.color || '#ccc',
                                count: 0,
                                count2: 0,
                                sizeRows: maxX - minX + 1,
                                sizeCols: maxY - minY + 1,
                                rawShape: new Set(coords),
                            }
                        });

                        this.modelLoaded = true;
                        this.calculateResultMessage = "组件列表已更新";
                    } catch(e){
                        alert(e.message || "更新组件列表失败");
                    }
                },

                async loadPresetsFromServer(){
                    try {
                        const res = await fetch(`./presets.json?t=${Date.now()}`);
                        if(!res.ok) throw new Error('加载预设文件失败');
                        const json = await res.json();
                        
                        this.presets = json;
                        this.processPresetList();
                    } catch(e){
                        console.warn('加载预设失败:', e.message);
                        this.presets = {};
                        this.presetList = [];
                    }
                },

                processPresetList(){
                    let filtered = Object.entries(this.presets)
                        .filter(([id, preset]) => 
                            preset.name && 
                            preset.name.toLowerCase().includes(this.presetSearchText.toLowerCase())
                        )
                        .sort((a, b) => a[1].name.localeCompare(b[1].name, 'zh'));
                    
                    this.presetList = filtered.map(([id, preset]) => ({
                        id,
                        name: preset.name,
                        preset
                    }));
                },

                onPresetSearchInput(){
                    this.processPresetList();
                    this.selectedPresetId = null;
                },
                onRowsChange() {
                    this.boardColsTmp = this.boardRowsTmp;
                },

                selectPreset(presetId){
                    this.selectedPresetId = this.selectedPresetId === presetId ? null : presetId;
                },

                onButtonModeToggls() {
                    if (this.calculateRunning) {
                        alert('计算中无法切换输入模式');
                        this.useButton = !this.useButton;
                        return;
                    }
                },

                incrementTarget(type, index, maxValue) {
                    if (this.calculateRunning) return;
                    if (type === 'row') {
                        this.rowTargets[index] = (this.rowTargets[index] + 1) % (maxValue + 1);
                        this.$set(this.rowTargets, index, this.rowTargets[index]);
                    } else if (type === 'row2') {
                        this.row2Targets[index] = (this.row2Targets[index] + 1) % (maxValue + 1);
                        this.$set(this.row2Targets, index, this.row2Targets[index]);
                    } else if (type === 'col') {
                        this.colTargets[index] = (this.colTargets[index] + 1) % (maxValue + 1);
                        this.$set(this.colTargets, index, this.colTargets[index]);
                    } else if (type === 'col2') {
                        this.col2Targets[index] = (this.col2Targets[index] + 1) % (maxValue + 1);
                        this.$set(this.col2Targets, index, this.col2Targets[index]);
                    }
                },

                decrementTarget(type, index, maxValue) {
                    if (this.calculateRunning) return;
                    if (type === 'row') {
                        this.rowTargets[index] = (this.rowTargets[index] - 1 + maxValue + 1) % (maxValue + 1);
                        this.$set(this.rowTargets, index, this.rowTargets[index]);
                    } else if (type === 'row2') {
                        this.row2Targets[index] = (this.row2Targets[index] - 1 + maxValue + 1) % (maxValue + 1);
                        this.$set(this.row2Targets, index, this.row2Targets[index]);
                    } else if (type === 'col') {
                        this.colTargets[index] = (this.colTargets[index] - 1 + maxValue + 1) % (maxValue + 1);
                        this.$set(this.colTargets, index, this.colTargets[index]);
                    } else if (type === 'col2') {
                        this.col2Targets[index] = (this.col2Targets[index] - 1 + maxValue + 1) % (maxValue + 1);
                        this.$set(this.col2Targets, index, this.col2Targets[index]);
                    }
                },


                refreshComponents(){
                    if(this.calculateRunning){
                        alert('计算中无法刷新组件列表');
                        return;
                    }
                    if(confirm('确定要清理本地缓存并刷新组件列表吗？')){
                        this.modelLoaded = false;
                        this.loadComponentsFromServer();
                        this.components.forEach(c => {
                            c.count = 0;
                            c.count2 = 0;
                        });
                        this.calculateResultMessage = "";
                    }
                },
                refreshPresets(){
                    if(this.calculateRunning){
                        alert('计算中无法刷新组件列表');
                        return;
                    }
                    if(confirm('确定要清理本地缓存并刷新预设列表吗？')){
                        this.loadPresetsFromServer();
                        this.calculateResultMessage = "";
                    }
                },
                setComponentCountType1(id, cnt) {
                    const comp = this.components.find(c => c.id === id);
                    if(comp) comp.count = cnt;
                },
                setComponentCountType2(id, cnt) {
                    const comp = this.components.find(c => c.id === id);
                    if(comp) comp.count2 = cnt;
                },
                async generateBoard() {
                    const rows = this.boardRowsTmp;
                    const cols = this.boardColsTmp;
                    if (!rows || rows < 1 || rows > 10 || !cols || cols < 1 || cols > 10) return;
                    this.boardRows = rows;
                    this.boardCols = cols;
                    if(!this.modelLoaded){
                        await this.loadComponentsFromServer();
                    }
                    this.boardGenerated = true;
                    this.calculateResultMessage = "";
                    this.answerPlaced = false;
                    this.rowTargets = Array(this.boardRows).fill(0);
                    this.colTargets = Array(this.boardCols).fill(0);
                    this.row2Targets = Array(this.boardRows).fill(0);
                    this.col2Targets = Array(this.boardCols).fill(0);
                    this.cells = [];
                    for (let r = 0; r < this.boardRows; r++) {
                        for (let c = 0; c < this.boardCols; c++) {
                            this.cells.push({
                                r,
                                c,
                                state: 0,
                                disabled: false,
                                placed: false,
                                compId: null
                            });
                        }
                    }
                    this.components.forEach(c => {
                        c.count = 0;
                        c.count2 = 0;
                    });
                },

                validateTarget(type, idx) {
                    if(type==='row'){
                        if(this.rowTargets[idx] < 0) this.rowTargets[idx] = 0;
                        if(this.rowTargets[idx] > this.boardCols) this.rowTargets[idx] = this.boardCols;
                    } else if(type==='row2'){
                        if(this.row2Targets[idx] < 0) this.row2Targets[idx] = 0;
                        if(this.row2Targets[idx] > this.boardCols) this.row2Targets[idx] = this.boardCols;
                    } else if(type==='col'){
                        if(this.colTargets[idx] < 0) this.colTargets[idx] = 0;
                        if(this.colTargets[idx] > this.boardRows) this.colTargets[idx] = this.boardRows;
                    } else if(type==='col2'){
                        if(this.col2Targets[idx] < 0) this.col2Targets[idx] = 0;
                        if(this.col2Targets[idx] > this.boardRows) this.col2Targets[idx] = this.boardRows;
                    }
                },

                toggleDisableCell(cell) {
                    if(this.calculateRunning) return;
                    if(this.answerPlaced){
                        let resetConfirm = confirm(
                            '当前已有计算结果, 修改禁用格子将导致答案失效\n是否重置答案? 点击"确定"将重置答案，点击"取消"将取消修改'
                        );
                        if(resetConfirm){
                            this.resetAnswer();
                        } else {
                            return;
                        }
                    }
                    
                    if(this.type2Enabled){
                        cell.state = (cell.state + 1) % 4;
                    } else {
                        cell.state = (cell.state + 1) % 3;
                    }
                    
                    if(cell.state !== 0){
                        cell.placed = false;
                        cell.compId = null;
                        cell.compInstanceId = null;
                    }
                },
                
                async exportPreset() {
                    if (!this.answerPlaced || this.calculateRunning){
                        if(!this.answerPlaced) alert("未计算出答案的预设无法导出");
                        return;
                    }
                    const confirmReset = confirm("导出预设将重置当前答案, 是否继续? ");
                    if (!confirmReset) return;
                    const R = {};
                    this.resetAnswer();
                    const name = prompt("请输入此预设的名称");
                    if (!name) {
                        alert("预设名称不能为空");
                        return;
                    }
                    R.name = name;
                    R.n = this.boardRows;
                    R.m = this.boardCols;
                    R.isType2Activated = this.type2Enabled;
                    R.target = {
                        row: this.rowTargets.slice(),
                        col: this.colTargets.slice(),
                        row2: this.type2Enabled ? this.row2Targets.slice() : Array(this.boardRows).fill(0),
                        col2: this.type2Enabled ? this.col2Targets.slice() : Array(this.boardCols).fill(0),
                    };
                    R.gridCell = this.cells
                        .filter(cell => (cell.state != 0))
                        .map(cell => ({
                        r: cell.r,
                        c: cell.c,
                        state: cell.state
                    }));
                    R.component = this.components
                        .filter(c => (c.count > 0 || (this.type2Enabled && c.count2 > 0)))
                        .map(c => ({
                        id: c.id,
                        count: c.count,
                        count2: this.type2Enabled ? c.count2 : 0
                    }));
                    try {
                        await navigator.clipboard.writeText(JSON.stringify(R));
                        alert("预设数据已复制到剪贴板");
                    } catch (err) {
                        alert("复制到剪贴板失败, 请手动复制：\n" + JSON.stringify(R, null, 4));
                    }
                },

                importPreset() {
                    if(this.calculateRunning){
                        alert('计算中无法导入预设');
                        return;
                    }

                    const jsonString = prompt('请输入预设');
                    if (jsonString === null) return;
                    if (!jsonString.trim()) {
                        alert('请输入有效的JSON数据');
                        return;
                    }
                    
                    try {
                        const presetInfo = JSON.parse(jsonString);
                        if (!presetInfo.n || !presetInfo.m || !presetInfo.name || !presetInfo.target || !presetInfo.gridCell || !presetInfo.component) {
                            alert('非法JSON');
                            return;
                        }
                        this.loadPreset(presetInfo);
                        
                    } catch (e) {
                        if (e instanceof SyntaxError) {
                            alert('JSON格式错误');
                        } else {
                            alert(`导入失败: ${e.message}`);
                        }
                    }
                },

                async loadPreset(presetInfo) {
                    if (!presetInfo) {
                        alert('预设数据不存在');
                        return false;
                    }

                    const confirmApply = confirm('导入预设将覆盖全部内容, 未保存的内容可能会丢失, 是否继续? ');
                    if (!confirmApply) return false;

                    try {
                        this.resetAll();
                        this.boardRowsTmp = presetInfo.n;
                        this.boardColsTmp = presetInfo.m || presetInfo.n;
                        this.boardRows = presetInfo.n;
                        this.boardCols = presetInfo.m || presetInfo.n;
                        this.type2Enabled = presetInfo.isType2Activated || false;
                        const N = this.boardRows;
                        const M = this.boardCols;
                        
                        this.cells = [];
                        for (let r = 0; r < N; r++) {
                            for (let c = 0; c < M; c++) {
                                this.cells.push({
                                    r,
                                    c,
                                    state: 0,
                                    disabled: false,
                                    placed: false,
                                    compId: null,
                                    compInstanceId: null,
                                });
                            }
                        }
                        
                        if(presetInfo.gridCell && Array.isArray(presetInfo.gridCell)){
                            presetInfo.gridCell.forEach(cellData => {
                                if(cellData.r >= 0 && cellData.r < N && cellData.c >= 0 && cellData.c < M){
                                    const idx = cellData.r * M + cellData.c;
                                    if(this.cells[idx]){
                                        this.cells[idx].state = cellData.state || 0;
                                    }
                                }
                            });
                        }
                        
                        this.rowTargets = presetInfo.target?.row?.slice() || Array(N).fill(0);
                        this.colTargets = presetInfo.target?.col?.slice() || Array(M).fill(0);
                        this.row2Targets = presetInfo.target?.row2?.slice() || Array(N).fill(0);
                        this.col2Targets = presetInfo.target?.col2?.slice() || Array(M).fill(0);
                        
                        this.components.forEach(c => {
                            c.count = 0;
                            c.count2 = 0;
                        });
                        
                        if(presetInfo.component && Array.isArray(presetInfo.component)){
                            presetInfo.component.forEach(compData => {
                                const comp = this.components.find(c => c.id === compData.id);
                                if(comp){
                                    comp.count = compData.count || 0;
                                    if(this.type2Enabled){
                                        comp.count2 = compData.count2 || 0;
                                    }
                                }
                            });
                        }
                        
                        this.boardGenerated = true;
                        this.calculateResultMessage = `已加载预设: ${presetInfo.name || '导入的预设'}`;
                        this.selectedPresetId = null;
                        this.processPresetList();
                        return true;
                    } catch(e) {
                        alert(`应用预设失败: ${e.message}`);
                        return false;
                    }
                },

                async applyPreset(){
                    if(!this.selectedPresetId){
                        alert('请选择一个预设');
                        return;
                    }
                    
                    const selectedPreset = this.presets[this.selectedPresetId];
                    this.loadPreset(selectedPreset);
                },

                // async applyPreset(){
                //     if(!this.selectedPresetId){
                //         alert('请选择一个预设');
                //         return;
                //     }
                    
                //     const selectedPreset = this.presets[this.selectedPresetId];
                //     if(!selectedPreset){
                //         alert('预设数据不存在');
                //         return;
                //     }

                //     const confirmApply = confirm('导入预设将覆盖全部内容, 未保存的内容可能会丢失, 是否继续? ');
                //     if(!confirmApply) return;
                    
                //     this.boardRowsTmp = selectedPreset.n;
                //     this.boardColsTmp = selectedPreset.m || selectedPreset.n;
                //     this.boardRows = selectedPreset.n;
                //     this.boardCols = selectedPreset.m || selectedPreset.n;
                //     this.type2Enabled = selectedPreset.isType2Activated || false;
                //     const N = this.boardRows;
                //     const M = this.boardCols;
                    
                //     this.cells = [];
                //     for (let r = 0; r < N; r++) {
                //         for (let c = 0; c < M; c++) {
                //             this.cells.push({
                //                 r,
                //                 c,
                //                 state: 0,
                //                 disabled: false,
                //                 placed: false,
                //                 compId: null,
                //                 compInstanceId: null,
                //             });
                //         }
                //     }
                    
                //     if(selectedPreset.gridCell && Array.isArray(selectedPreset.gridCell)){
                //         selectedPreset.gridCell.forEach(cellData => {
                //             if(cellData.r >= 0 && cellData.r < N && cellData.c >= 0 && cellData.c < M){
                //                 const idx = cellData.r * M + cellData.c;
                //                 if(this.cells[idx]){
                //                     this.cells[idx].state = cellData.state || 0;
                //                 }
                //             }
                //         });
                //     }
                    
                //     this.rowTargets = selectedPreset.target?.row?.slice() || Array(N).fill(0);
                //     this.colTargets = selectedPreset.target?.col?.slice() || Array(M).fill(0);
                //     this.row2Targets = selectedPreset.target?.row2?.slice() || Array(N).fill(0);
                //     this.col2Targets = selectedPreset.target?.col2?.slice() || Array(M).fill(0);
                    
                //     this.components.forEach(c => {
                //         c.count = 0;
                //         c.count2 = 0;
                //     });
                    
                //     if(selectedPreset.component && Array.isArray(selectedPreset.component)){
                //         selectedPreset.component.forEach(compData => {
                //             const comp = this.components.find(c => c.id === compData.id);
                //             if(comp){
                //                 comp.count = compData.count || 0;
                //                 if(this.type2Enabled){
                //                     comp.count2 = compData.count2 || 0;
                //                 }
                //             }
                //         });
                //     }
                    
                //     this.boardGenerated = true;
                //     this.calculateResultMessage = `已加载预设: ${selectedPreset.name}`;
                //     this.selectedPresetId = null;
                //     // this.presetSearchText = "";
                //     this.processPresetList();
                // },

                async startCalculation() {
                    this.calculateResultMessage = "";
                    
                    const N = this.boardRows;
                    const M = this.boardCols;

                    if (this.rowTargets.some(v => v < 0 || v > M) ||
                        this.colTargets.some(v => v < 0 || v > N)) {
                        this.calculateResultMessage = "输入错误: 绿色组件行列目标数字超出范围";
                        return;
                    }
                    if (this.type2Enabled) {
                        if (this.row2Targets.some(v => v < 0 || v > M) ||
                            this.col2Targets.some(v => v < 0 || v > N)) {
                            this.calculateResultMessage = "输入错误: 蓝色组件行列目标数字超出范围";
                            return;
                        }
                    }

                    const rowTargets = this.rowTargets.slice();
                    const colTargets = this.colTargets.slice();
                    const row2Targets = this.type2Enabled ? this.row2Targets.slice() : Array(N).fill(0);
                    const col2Targets = this.type2Enabled ? this.col2Targets.slice() : Array(M).fill(0);

                    const totalNeeded = rowTargets.reduce((a, b) => a + b, 0);
                    const sumCol = colTargets.reduce((a, b) => a + b, 0);
                    if (totalNeeded !== sumCol) {
                        this.calculateResultMessage = "输入错误: 绿色组件行/列目标之和不相等";
                        return;
                    }
                    const totalNeeded2 = row2Targets.reduce((a, b) => a + b, 0);
                    const sumCol2 = col2Targets.reduce((a, b) => a + b, 0);
                    if (totalNeeded2 !== sumCol2) {
                        this.calculateResultMessage = "输入错误: 蓝色组件行/列目标之和不相等";
                        return;
                    }

                    this.calculateRunning = true;
                    try {
                        this.cells.forEach(cell => {
                            cell.placed = false;
                            cell.compId = null;
                            cell.compInstanceId = null;
                        });
                        this.answerPlaced = false;
                        this.placedInstances = [];

                        const board = Array.from({ length: N }, () => Array(M).fill(0));
                        let totalEmpty = 0;

                        const rowLitCount = Array(N).fill(0);
                        const colLitCount = Array(M).fill(0);
                        const rowLit2Count = Array(N).fill(0);
                        const colLit2Count = Array(M).fill(0);

                        for (let r = 0; r < N; r++) {
                            for (let c = 0; c < M; c++) {
                                const cell = this.cells[r * M + c];
                                if (cell.state === 0) {
                                    board[r][c] = 0;
                                    totalEmpty++;
                                } else {
                                    board[r][c] = -1;
                                    if (cell.state === 2) {
                                        rowLitCount[r]++;
                                        colLitCount[c]++;
                                    } else if (cell.state === 3) {
                                        rowLit2Count[r]++;
                                        colLit2Count[c]++;
                                    }
                                }
                            }
                        }

                        for (let i = 0; i < N; i++) {
                            if (rowLitCount[i] > rowTargets[i]) {
                                this.calculateResultMessage = "输入错误: 某行的绿色组件锁定常亮格大于需求量";
                                this.calculateRunning = false;
                                return;
                            }
                            if (rowLit2Count[i] > row2Targets[i]) {
                                this.calculateResultMessage = "输入错误: 某行的蓝色组件锁定常亮格大于需求量";
                                this.calculateRunning = false;
                                return;
                            }
                        }

                        for (let i = 0; i < M; i++){
                            if (colLitCount[i] > colTargets[i]) {
                                this.calculateResultMessage = "输入错误: 某列的绿色组件锁定常亮格大于需求量";
                                this.calculateRunning = false;
                                return;
                            }
                            if (colLit2Count[i] > col2Targets[i]) {
                                this.calculateResultMessage = "输入错误: 某列的蓝色组件锁定常亮格大于需求量";
                                this.calculateRunning = false;
                                return;
                            }
                        }

                        const boardSatisfiedNow = () => {
                            for (let i = 0; i < N; i++) {
                                if (rowLitCount[i] !== rowTargets[i]) return false;
                                if (rowLit2Count[i] !== row2Targets[i]) return false;
                            }
                            for(let i = 0; i < M; i++){
                                if (colLitCount[i] !== colTargets[i]) return false;
                                if (colLit2Count[i] !== col2Targets[i]) return false;
                            }
                            return true;
                        };

                        if (boardSatisfiedNow()) {
                            this.calculateResultMessage = "无需放置组件: 需求已满足";
                            this.answerPlaced = true;
                            this.calculateRunning = false;
                            return;
                        }

                        let currentGreens = rowLitCount.reduce((a, b) => a + b, 0);
                        let currentBlues = rowLit2Count.reduce((a, b) => a + b, 0);
                        if (totalEmpty < (totalNeeded - currentGreens) + (totalNeeded2 - currentBlues)) {
                            this.calculateResultMessage = "无解: 可用格不足";
                            this.calculateRunning = false;
                            return;
                        }

                        const rowEmptyCount = Array(N).fill(0);
                        const colEmptyCount = Array(M).fill(0);
                        for (let r = 0; r < N; r++) {
                            for (let c = 0; c < M; c++) {
                                if (board[r][c] === 0) {
                                    rowEmptyCount[r]++;
                                    colEmptyCount[c]++;
                                }
                            }
                        }

                        const shapeSetToArray = (shapeSet) => Array.from(shapeSet, e => e.split(",").map(Number));
                        const rotationsCache = {};
                        for (let i = 0; i < this.components.length; i++) {
                            const rots = this.getRotations(this.components[i].shapeSet);
                            rotationsCache[i] = rots.map(s => shapeSetToArray(s));
                        }

                        const placementsByComp = Array(this.components.length).fill(null).map(() => []);
                        for (let compId = 0; compId < this.components.length; compId++) {
                            const rots = rotationsCache[compId];
                            for (const shapeArr of rots) {
                                const maxDx = Math.max(...shapeArr.map(p => p[0]));
                                const maxDy = Math.max(...shapeArr.map(p => p[1]));
                                const maxR = N - maxDx;
                                const maxC = M - maxDy;
                                for (let r0 = 0; r0 < maxR; r0++) {
                                    for (let c0 = 0; c0 < maxC; c0++) {
                                        let ok = true;
                                        const coords = [];
                                        for (const [dx, dy] of shapeArr) {
                                            const rr = r0 + dx, cc = c0 + dy;
                                            if (board[rr][cc] !== 0) { ok = false; break; }
                                            coords.push([rr, cc]);
                                        }
                                        if (!ok) continue;

                                        const rowDelta = {};
                                        const colDelta = {};
                                        for (const [rr, cc] of coords) {
                                            rowDelta[rr] = (rowDelta[rr] || 0) + 1;
                                            colDelta[cc] = (colDelta[cc] || 0) + 1;
                                        }

                                        let staticOk = true;
                                        for (const rStr in rowDelta) {
                                            const r = +rStr;
                                            if (rowTargets[r] === 0 && row2Targets[r] === 0) { staticOk = false; break; }
                                        }
                                        if (!staticOk) continue;
                                        for (const cStr in colDelta) {
                                            const c = +cStr;
                                            if (colTargets[c] === 0 && col2Targets[c] === 0) { staticOk = false; break; }
                                        }
                                        if (!staticOk) continue;

                                        placementsByComp[compId].push({
                                            coords,
                                            rowDelta,
                                            colDelta,
                                            size: coords.length
                                        });
                                    }
                                }
                            }
                        }

                        const compAreas = this.components.map(c => c.shapeSet.size);
                        const compIdsInOrder = [];
                        this.components.forEach((c, i) => {
                            for (let k = 0; k < (c.count || 0); k++) compIdsInOrder.push({ compId: i, type: 1 });
                            if (this.type2Enabled) {
                                for (let k = 0; k < (c.count2 || 0); k++) compIdsInOrder.push({ compId: i, type: 2 });
                            }
                        });
                        compIdsInOrder.sort((a, b) => compAreas[b.compId] - compAreas[a.compId]);

                        const remCap1FromIdx = new Array(compIdsInOrder.length + 1).fill(0);
                        const remCap2FromIdx = new Array(compIdsInOrder.length + 1).fill(0);
                        for (let i = compIdsInOrder.length - 1; i >= 0; i--) {
                            remCap1FromIdx[i] = remCap1FromIdx[i + 1] + (compIdsInOrder[i].type === 1 ? compAreas[compIdsInOrder[i].compId] : 0);
                            remCap2FromIdx[i] = remCap2FromIdx[i + 1] + (compIdsInOrder[i].type === 2 ? compAreas[compIdsInOrder[i].compId] : 0);
                        }

                        const canStillSatisfy = (compIndex) => {
                            for (let i = 0; i < N; i++) {
                                if (rowLitCount[i] > rowTargets[i]) return false;
                                if (rowLit2Count[i] > row2Targets[i]) return false;
                            }
                            for (let i = 0; i < M; i++) {
                                if (colLitCount[i] > colTargets[i]) return false;
                                if (colLit2Count[i] > col2Targets[i]) return false;
                            }

                            for (let i = 0; i < N; i++) {
                                const gRowRemain = rowTargets[i] - rowLitCount[i];
                                const bRowRemain = row2Targets[i] - rowLit2Count[i];
                                if (gRowRemain + bRowRemain > rowEmptyCount[i]) return false;

                            }
                            for (let i = 0; i < M; i++) {
                                const gColRemain = colTargets[i] - colLitCount[i];
                                const bColRemain = col2Targets[i] - colLit2Count[i];
                                if (gColRemain + bColRemain > colEmptyCount[i]) return false;
                            }

                            const remainG = totalNeeded - currentGreens;
                            const remainB = totalNeeded2 - currentBlues;
                            if (remainG < 0 || remainB < 0) return false;
                            const remainTotal = remainG + remainB;
                            if (remainTotal > totalEmpty) return false;

                            if (remainG > remCap1FromIdx[compIndex]) return false;
                            if (remainB > remCap2FromIdx[compIndex]) return false;

                            return true;
                        };

                        const boardSatisfied = () => {
                            for (let i = 0; i < N; i++) {
                                if (rowLitCount[i] !== rowTargets[i]) return false;
                                if (rowLit2Count[i] !== row2Targets[i]) return false;
                            }
                            for (let i = 0; i < M; i++) {
                                if (colLitCount[i] !== colTargets[i]) return false;
                                if (colLit2Count[i] !== col2Targets[i]) return false;
                            }
                            return true;
                        };

                        let compInstanceCounter = 0;
                        const placePlacement = (placement, compId, ct) => {
                            for (const rStr in placement.rowDelta) {
                                const r = +rStr;
                                if (ct === 1) {
                                    if (rowLitCount[r] + placement.rowDelta[r] > rowTargets[r]) return null;
                                } else {
                                    if (rowLit2Count[r] + placement.rowDelta[r] > row2Targets[r]) return null;
                                }
                            }
                            for (const cStr in placement.colDelta) {
                                const c = +cStr;
                                if (ct === 1) {
                                    if (colLitCount[c] + placement.colDelta[c] > colTargets[c]) return null;
                                } else {
                                    if (colLit2Count[c] + placement.colDelta[c] > col2Targets[c]) return null;
                                }
                            }
                            for (const [rr, cc] of placement.coords) {
                                if (board[rr][cc] !== 0) return null;
                            }

                            const instanceId = compInstanceCounter++;
                            for (const [rr, cc] of placement.coords) {
                                board[rr][cc] = instanceId + 1;
                                if (ct === 1) {
                                    rowLitCount[rr]++;
                                    colLitCount[cc]++;
                                    currentGreens++;
                                } else {
                                    rowLit2Count[rr]++;
                                    colLit2Count[cc]++;
                                    currentBlues++;
                                }
                                rowEmptyCount[rr]--;
                                colEmptyCount[cc]--;
                                totalEmpty--;

                                const cell = this.cells[rr * M + cc];
                                cell.placed = true;
                                cell.compId = compId;
                                cell.compInstanceId = instanceId;
                                cell.state = (ct === 1) ? 2 : 3;
                            }
                            this.placedInstances.push({
                                instanceId,
                                compId,
                                type: ct,
                                name: this.components[compId].name,
                                coords: placement.coords.slice(),
                                color: this.components[compId].color
                            });
                            return instanceId;
                        };

                        const removePlacement = (placement, instanceId, ct) => {
                            for (const [rr, cc] of placement.coords) {
                                board[rr][cc] = 0;
                                if (ct === 1) {
                                    rowLitCount[rr]--;
                                    colLitCount[cc]--;
                                    currentGreens--;
                                } else {
                                    rowLit2Count[rr]--;
                                    colLit2Count[cc]--;
                                    currentBlues--;
                                }
                                rowEmptyCount[rr]++;
                                colEmptyCount[cc]++;
                                totalEmpty++;

                                const cell = this.cells[rr * M + cc];
                                cell.placed = false;
                                cell.compId = null;
                                cell.compInstanceId = null;
                                cell.state = 0;
                            }
                            this.placedInstances = this.placedInstances.filter(inst => inst.instanceId !== instanceId);
                        };

                        const tryPlacements = (compIndex) => {
                            if (boardSatisfied()) return true;
                            if (!canStillSatisfy(compIndex)) return false;
                            if (compIndex >= compIdsInOrder.length) return false;

                            const { compId, type } = compIdsInOrder[compIndex];
                            const candidates = placementsByComp[compId];

                            const sorted = candidates.slice().sort((a, b) => b.size - a.size);

                            for (const placement of sorted) {
                                let touchesSaturated = false;
                                for (const rStr in placement.rowDelta) {
                                    const r = +rStr;
                                    if ((type === 1 && rowLitCount[r] >= rowTargets[r]) ||
                                        (type === 2 && rowLit2Count[r] >= row2Targets[r])) {
                                        touchesSaturated = true; break;
                                    }
                                }
                                if (!touchesSaturated) {
                                    for (const cStr in placement.colDelta) {
                                        const c = +cStr;
                                        if ((type === 1 && colLitCount[c] >= colTargets[c]) ||
                                            (type === 2 && colLit2Count[c] >= col2Targets[c])) {
                                            touchesSaturated = true; break;
                                        }
                                    }
                                }
                                if (touchesSaturated) continue;

                                const iid = placePlacement(placement, compId, type);
                                if (iid !== null) {
                                    if (canStillSatisfy(compIndex + 1)) {
                                        if (tryPlacements(compIndex + 1)) return true;
                                    }
                                    removePlacement(placement, iid, type);
                                }
                            }

                            if (tryPlacements(compIndex + 1)) return true;

                            return false;
                        };

                        const solved = tryPlacements(0);

                        if (solved) {
                            const usedInstanceIds = new Set();
                            this.cells.forEach(cell => {
                                if (cell.placed && cell.compInstanceId !== null && cell.compInstanceId !== undefined) {
                                    usedInstanceIds.add(cell.compInstanceId);
                                }
                            });
                            const sortedInstanceIds = Array.from(usedInstanceIds).sort((a, b) => a - b);
                            const idMap = new Map();
                            sortedInstanceIds.forEach((oldId, idx) => idMap.set(oldId, idx + 1));
                            this.cells.forEach(cell => {
                                if (cell.placed && cell.compInstanceId !== null && cell.compInstanceId !== undefined) {
                                    cell.compInstanceId = idMap.get(cell.compInstanceId);
                                }
                            });

                            this.calculateResultMessage = "成功找到一个可行解。";
                            this.answerPlaced = true;
                        } else {
                            this.calculateResultMessage = "此输入内容无匹配解。";
                            this.answerPlaced = false;
                        }
                    } catch (e) {
                        console.error(e);
                        this.calculateResultMessage = "计算过程中出现异常";
                        this.answerPlaced = false;
                    } finally {
                        this.calculateRunning = false;
                    }
                },
                onType2Toggle() {
                    if (this.boardGenerated && !this.type2Enabled) {
                        let confirmReset = window.confirm('取消蓝色组件计算会重置全部内容，是否继续? ');
                        if (confirmReset) {
                            this.resetAll();
                        } else {
                            this.type2Enabled = !this.type2Enabled;
                        }
                    }
                },
                resetAnswer() {
                    if(!this.boardGenerated) return;
                    this.calculateResultMessage = "";
                    this.cells.forEach(cell => {
                        if(cell.placed){
                            cell.placed = false;
                            cell.compId = null;
                            cell.state = 0;
                            cell.compInstanceId = null;
                        }
                    });
                    this.answerPlaced = false;
                },
                resetAll() {
                    if(!this.boardGenerated) return;
                    this.calculateResultMessage = "";
                    this.answerPlaced = false;
                    this.rowTargets = Array(this.boardRows).fill(0);
                    this.colTargets = Array(this.boardCols).fill(0);
                    this.row2Targets = Array(this.boardRows).fill(0);
                    this.col2Targets = Array(this.boardCols).fill(0);
                    this.components.forEach(c => {
                        c.count = 0;
                        c.count2 = 0;
                    });
                    this.cells = [];
                    for (let r = 0; r < this.boardRows; r++) {
                        for (let c = 0; c < this.boardCols; c++) {
                            this.cells.push({
                                r,
                                c,
                                state: 0,
                                disabled: false,
                                placed: false,
                                compId: null,
                                compInstanceId: null,
                            });
                        }
                    }
                },
                getRotations(shapeSet) {
                    const coords = Array.from(shapeSet, s => s.split(",").map(Number));
                    const normalize = (arr) => {
                        let minR = Math.min(...arr.map(p => p[0]));
                        let minC = Math.min(...arr.map(p => p[1]));
                        return arr.map(p => [p[0] - minR, p[1] - minC]);
                    };
                    const toSet = arr => new Set(arr.map(p => p.join(",")));

                    const rotations = [];
                    let r0 = normalize(coords);
                    rotations.push(toSet(r0));
                    rotations.push(toSet(normalize(r0.map(p => [p[1], -p[0]]))));
                    rotations.push(toSet(normalize(r0.map(p => [-p[0], -p[1]]))));
                    rotations.push(toSet(normalize(r0.map(p => [-p[1], p[0]]))));

                    const uniq = [];
                    rotations.forEach(s => {
                        if(!uniq.some(us => this.setEquals(us, s))){
                            uniq.push(s);
                        }
                    });
                    return uniq;
                },
                setEquals(a, b) {
                    if(a.size !== b.size) return false;
                    for(let v of a){
                        if(!b.has(v)) return false;
                    }
                    return true;
                },
                getCellBorderStyle(cell, idx) {
                    const N = this.boardRows;
                    const M = this.boardCols;
                    const r = Math.floor(idx / M);
                    const c = idx % M;
                    const style = {
                        borderTop: '2.2px solid transparent',
                        borderBottom: '2.2px solid transparent',
                        borderLeft: '2.2px solid transparent',
                        borderRight: '2.2px solid transparent',
                        borderRadius: '8px',
                    };
                    if (r === 0) {
                        style.borderTop = '2.2px solid #333';
                    } else {
                        const up = this.cells[(r - 1) * M + c];
                        if (!up.placed || up.compInstanceId !== cell.compInstanceId) {
                            style.borderTop = '2.2px solid #333';
                        }
                    }
                    if (r === N -1) {
                        style.borderBottom = '2.2px solid #333';
                    } else {
                        const down = this.cells[(r + 1) * M + c];
                        if (!down.placed || down.compInstanceId !== cell.compInstanceId) {
                            style.borderBottom = '2.2px solid #333';
                        }
                    }
                    if (c === 0) {
                        style.borderLeft = '2.2px solid #333';
                    } else {
                        const left = this.cells[r * M + (c - 1)];
                        if (!left.placed || left.compInstanceId !== cell.compInstanceId) {
                            style.borderLeft = '2.2px solid #333';
                        }
                    }
                    if (c === M -1) {
                        style.borderRight = '2.2px solid #333';
                    } else {
                        const right = this.cells[r * M + (c + 1)];
                        if (!right.placed || right.compInstanceId !== cell.compInstanceId) {
                            style.borderRight = '2.2px solid #333';
                        }
                    }
                    return style;
                }
            },
            mounted() {
                this.loadComponentsFromServer();
                this.loadPresetsFromServer();
                this.generateBoard();
            }
        });
        app.mount('#app');
    </script>
</body>
</html>
